# Иерархический чанкер для SmartChanker

## Обзор

Иерархический чанкер - это расширение SmartChanker, которое решает проблему создания семантически корректных чанков из документов с многоуровневой нумерацией. Основная идея - сначала преобразовать Word-документ в плоский текст, а затем восстановить иерархию для создания чанков по границам разделов.

## Проблема

При работе с Word-документами часто возникают проблемы:
- Пользователи неаккуратно работают с многоуровневыми списками
- Нумерация может сбиваться (пропуски, дубли)
- Создание чанков по произвольным границам нарушает семантическую целостность
- RAG-системы получают фрагменты без контекста

## Решение

Иерархический чанкер:
1. **Парсит иерархию** из плоского текста с нумерацией
2. **Создает семантические чанки** по границам разделов
3. **Сохраняет контекст** - каждый чанк знает свой родительский раздел
4. **Обрабатывает списки** - плоские списки остаются целыми

## Ключевые допущения и эвристики

### Основные допущения

1. **Единственный источник истины - номер раздела**
   - Отступы (табы, пробелы) НЕ используются для определения уровня
   - Иерархия определяется только по структуре номера (1.1.2 = уровень 3)

2. **Нумерация всегда в начале абзаца**
   - Может предшествовать только пробелы или слова "Раздел", "Пункт", "Часть"
   - Нумерация никогда не встречается в середине абзаца

3. **Ошибки нумерации игнорируются**
   - Пропуски номеров (1.1.1, 1.1.3) - не критично
   - Дублирование номеров - не критично
   - Для конечной задачи (RAG) важна структура, а не корректность нумерации

4. **Плоские списки в разделах не создают новые разделы**
   - Элементы списка (1), 2), 3)) добавляются к содержимому родительского раздела
   - Если список предшествует абзацу с двоеточием, они объединяются в один чанк

### Эвристики распознавания

1. **Исключение ложных срабатываний**
   ```python
   # Исключаем годы
   if re.match(r'^(19|20)\d{2}$', number):
       return False
   
   # Исключаем полные даты
   if re.match(r'^\d{1,2}\.\d{1,2}\.(\d{2}|\d{4})$', number):
       return False
   
   # НЕ исключаем десятичные числа (могут быть нумерацией)
   # 3.14 - может быть номером раздела
   ```

2. **Приоритет паттернов**
   - `simple_numbered` (1)) проверяется ПЕРЕД `multi_level` (1.1)
   - Это позволяет правильно обрабатывать "1)" как простую нумерацию

3. **Обработка префиксов**
   - Поддерживаются префиксы: "Раздел", "Пункт", "Часть"
   - Префиксы используются для распознавания, но не сохраняются в данных

4. **Семантическая группировка**
   - Абзац с двоеточием + список = единая смысловая конструкция
   - Стараемся сохранить такие конструкции в одном чанке

## Архитектура

### Модули

1. **`hierarchy_parser.py`** - парсинг иерархии из плоского текста
2. **`semantic_chunker.py`** - генерация семантических чанков
3. **`hierarchical_chunker.py`** - интеграция и API

### Классы

- `HierarchyParser` - парсинг иерархии
- `SemanticChunker` - генерация чанков
- `HierarchicalChunker` - основной API
- `SectionNode` - узел раздела
- `Chunk` - семантический чанк
- `ChunkMetadata` - метаданные чанка

## Использование

### Базовое использование

```python
from smart_chanker import HierarchicalChunker

# Конфигурация
config = {
    'target_level': 3,  # Чанки на уровне 1.1.1, 1.1.2, и т.д.
    'max_chunk_size': 1000,
    'preserve_lists': True
}

# Создаем чанкер
chunker = HierarchicalChunker(config)

# Обрабатываем текст
result = chunker.process_text(text)

# Получаем чанки
chunks = result['chunks']
```

### Получение контекста раздела

```python
# Получаем контекст конкретного раздела
context = chunker.get_section_context(text, "1.1.2")

print(f"Раздел: {context['section']['title']}")
print(f"Родитель: {context['parent']['title']}")
print(f"Дочерние: {[child['title'] for child in context['children']]}")
```

### Работа с метаданными

```python
for chunk in chunks:
    metadata = chunk['metadata']
    
    print(f"ID: {metadata['chunk_id']}")
    print(f"Номер в разделе: {metadata['chunk_number']}")
    print(f"Путь: {' > '.join(metadata['section_path'])}")
    print(f"Родитель: {metadata['parent_section']}")
    print(f"Дочерние: {metadata['children']}")
    print(f"Содержит списки: {metadata['contains_lists']}")
    print(f"Полный раздел: {metadata['is_complete_section']}")
```

### Работа с разделами

```python
# Получаем все разделы
sections = result['sections']

for section in sections:
    print(f"Раздел: {section['number']} - {section['title']}")
    print(f"Уровень: {section['level']}")
    print(f"Родитель: {section['parent_number']}")
    print(f"Дочерние: {section['children']}")
    print(f"Чанки: {len(section['chunks'])}")
    print()
```

## Поддерживаемые типы нумерации

### Многоуровневая нумерация
- `1.1.2.` - с точкой
- `1.1.2` - без точки
- `Раздел 1.1.2.` - с префиксом
- `Пункт 1.1.2` - с префиксом

### Простая нумерация
- `1)` - с закрывающей скобкой
- `1).` - с точкой
- `Раздел 1)` - с префиксом

### Буквенная нумерация
- `а.` - русская буква
- `a.` - латинская буква
- `Раздел а.` - с префиксом

### Маркеры списков
- `•` - маркер
- `-` - дефис
- `*` - звездочка

## Алгоритм работы

### 1. Парсинг иерархии

1. **Разбивка на строки** - текст разбивается на отдельные строки
2. **Классификация элементов** - каждая строка классифицируется по типу:
   - `multi_level` - многоуровневая нумерация (1.1.2)
   - `simple_numbered` - простая нумерация (1))
   - `lettered` - буквенная нумерация (а.)
   - `bulleted` - маркеры списков (•, -, *)
   - `paragraph` - обычный текст

3. **Построение иерархии** - используется стек для отслеживания текущего уровня
4. **Обработка плоских списков** - элементы списков добавляются к содержимому родительского раздела

### 2. Генерация чанков

1. **Проверка размера** - если раздел помещается в один чанк, создается один чанк
2. **Разбивка больших разделов** - если не помещается, разбивается на несколько чанков
3. **Семантическая группировка** - абзацы с двоеточием + списки объединяются
4. **Генерация метаданных** - создаются UUID, порядковые номера, контекстная информация

## Конфигурация

```python
config = {
    'target_level': 3,           # Уровень для чанкинга
    'max_chunk_size': 1000,      # Максимальный размер чанка
    'preserve_lists': True,      # Сохранять списки целиком
    'include_parent_context': True  # Включать контекст родителя
}
```

## Метаданные чанков

```python
@dataclass
class ChunkMetadata:
    chunk_id: str              # Уникальный UUID чанка
    chunk_number: int          # Порядковый номер чанка в разделе (1, 2, 3...)
    section_path: List[str]    # Путь в иерархии (["1", "1.1", "1.1.2"])
    parent_section: str        # Номер родительского раздела ("1.1")
    section_level: int         # Уровень раздела (3)
    children: List[str]        # Номера дочерних разделов (["1.1.2.1", "1.1.2.2"])
    word_count: int            # Количество слов
    char_count: int            # Количество символов
    contains_lists: bool       # Содержит ли списки
    is_complete_section: bool  # Полный раздел или часть
```

### Структура раздела

```python
@dataclass
class SectionNode:
    number: str                # Номер раздела ("1.1.2")
    title: str                 # Заголовок раздела
    level: int                 # Уровень вложенности
    content: str               # Содержимое раздела
    parent: SectionNode        # Родительский раздел
    children: List[SectionNode] # Дочерние разделы
    chunks: List[str]          # UUID чанков в разделе
```

### Логика `is_complete_section`

- **`True`** - раздел помещается в один чанк
- **`False`** - раздел разбит на несколько чанков

Это важно для RAG-систем - они могут понять, содержит ли чанк полный раздел или только его часть.

## Примеры

### Тестовый скрипт

Запустите `test_smart_chanker_hierarchical.py` для демонстрации работы:

```bash
python test_smart_chanker_hierarchical.py
```

Скрипт покажет:
- Структуру разделов с отступами по уровням
- Количество чанков в каждом разделе
- Детальную информацию о каждом чанке
- Сохранит результат в JSON файл

### Интеграция с RAG

```python
# Создаем чанки для RAG-системы
chunker = HierarchicalChunker({'target_level': 3})
result = chunker.process_text(document_text)

# Используем метаданные для контекстного поиска
for chunk in result['chunks']:
    if chunk['metadata']['contains_lists']:
        # Обрабатываем чанки со списками
        process_list_chunk(chunk)
    else:
        # Обрабатываем обычные чанки
        process_text_chunk(chunk)
```

## Преимущества

1. **Семантическая целостность** - чанки не разрывают смысловые блоки
2. **Контекстная информация** - каждый чанк знает свое место в иерархии
3. **Гибкость** - настраиваемые уровни чанкинга
4. **Надежность** - обработка неаккуратного форматирования
5. **RAG-оптимизация** - метаданные для улучшения поиска

## Ограничения

1. **Работает только с текстом, содержащим нумерацию**
   - Не подходит для документов без структурированной нумерации
   - Требует предварительной обработки Word-документов в плоский текст

2. **Зависит от качества исходного форматирования**
   - Нумерация должна быть в начале абзацев
   - Слишком неаккуратное форматирование может привести к ошибкам

3. **Не обрабатывает сложные структуры**
   - Сложные таблицы и изображения
   - Вложенные таблицы в Word
   - Специальные символы и форматирование

4. **Ограничения эвристик**
   - Может неправильно распознать нестандартную нумерацию
   - Ложные срабатывания на даты и годы (частично решено)
   - Не обрабатывает римские цифры (I, II, III)

5. **Производительность**
   - Большие документы могут обрабатываться медленно
   - Многоуровневые структуры требуют больше памяти

## Планы развития

1. **Поддержка дополнительных типов нумерации**
   - Римские цифры (I, II, III)
   - Буквенно-цифровая нумерация (1a, 1b, 1c)
   - Смешанная нумерация

2. **Улучшение эвристик**
   - Более точное распознавание дат и времени
   - Обработка специальных символов
   - Поддержка нестандартных форматов

3. **Оптимизация производительности**
   - Параллельная обработка больших документов
   - Кэширование результатов парсинга
   - Инкрементальная обработка

4. **Расширенная интеграция**
   - Прямая работа с Word-документами
   - Поддержка PDF и других форматов
   - API для внешних систем

5. **Аналитика и визуализация**
   - Статистика по структуре документов
   - Визуализация иерархии
   - Анализ качества чанкинга

## Практические рекомендации

### Подготовка документов

1. **Проверьте нумерацию** - убедитесь, что нумерация начинается с начала абзацев
2. **Используйте стандартные форматы** - 1.1.2, 1), а. - работают лучше всего
3. **Избегайте сложного форматирования** - табы и отступы не используются для определения уровня
4. **Проверьте даты** - убедитесь, что даты не конфликтуют с нумерацией

### Настройка параметров

1. **`target_level`** - выбирайте уровень, который соответствует вашим потребностям
   - Уровень 2 (1.1, 1.2) - для общих разделов
   - Уровень 3 (1.1.1, 1.1.2) - для детальных подразделов
   - Уровень 4+ - для очень детальной структуры

2. **`max_chunk_size`** - учитывайте ограничения вашей RAG-системы
   - 500-1000 символов - для быстрого поиска
   - 1000-2000 символов - для более полного контекста
   - 2000+ символов - для очень детального анализа

3. **`preserve_lists`** - всегда оставляйте `True` для семантической целостности

### Отладка проблем

1. **Проверьте логи** - используйте отладочные выводы для понимания процесса
2. **Анализируйте метаданные** - `is_complete_section` покажет, правильно ли разбиты разделы
3. **Проверьте иерархию** - убедитесь, что `parent_section` и `children` корректны
4. **Тестируйте на малых документах** - начните с простых примеров
